"""–ö–ª–∏–µ–Ω—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Tinkoff Investments API."""

from datetime import datetime, timedelta
from typing import Optional

import pandas as pd
from tinkoff.invest import Client, RequestError
from tinkoff.invest.sandbox.client import SandboxClient
from tinkoff.invest.schemas import CandleInterval

import config


class TinkoffClient:
    def __init__(self):
        self.token = config.TINKOFF_TOKEN
        self.sandbox_mode = config.SANDBOX_MODE
        print(f"üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TinkoffClient")
        print(f"   –†–µ–∂–∏–º: {'–ü–ï–°–û–ß–ù–ò–¶–ê' if self.sandbox_mode else '–†–ï–ê–õ–¨–ù–´–ï –¢–û–†–ì–ò'}")
        print(f"   –¢–æ–∫–µ–Ω: {self.token[:10]}...{self.token[-5:]}")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        try:
            if self.sandbox_mode:
                with SandboxClient(self.token) as client:
                    # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ –≤ –ø–µ—Å–æ—á–Ω–∏—Ü–µ
                    accounts = client.users.get_accounts()
                    print(
                        f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ SANDBOX —É—Å–ø–µ—à–Ω–æ! –ù–∞–π–¥–µ–Ω–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {len(accounts.accounts)}"
                    )
            else:
                with Client(self.token) as client:
                    # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ
                    accounts = client.users.get_accounts()
                    print(
                        f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ REAL —É—Å–ø–µ—à–Ω–æ! –ù–∞–π–¥–µ–Ω–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {len(accounts.accounts)}"
                    )
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ API: {e}")
            print("   –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–æ–∫–µ–Ω –∏ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ")

    def _get_client(self):
        """–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∫–ª–∏–µ–Ω—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞."""
        if self.sandbox_mode:
            return SandboxClient(self.token)
        else:
            return Client(self.token)

    def _get_figi_by_ticker(self, ticker: str) -> Optional[str]:
        """–ü–æ–ª—É—á–∏—Ç—å FIGI –ø–æ —Ç–∏–∫–µ—Ä—É."""
        with self._get_client() as client:
            try:
                print(f"üîç –ü–æ–∏—Å–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø–æ —Ç–∏–∫–µ—Ä—É: {ticker}")
                # –ü–æ–∏—Å–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø–æ —Ç–∏–∫–µ—Ä—É
                response = client.instruments.find_instrument(query=ticker)

                print(f"üìä –ù–∞–π–¥–µ–Ω–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤: {len(response.instruments)}")

                # –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º BBG FIGI –ø–µ—Ä–µ–¥ TCS
                bbg_instruments = []
                tcs_instruments = []

                for instrument in response.instruments:
                    print(
                        f"   - {instrument.ticker} | {instrument.name} | {instrument.figi}"
                    )
                    if instrument.ticker.upper() == ticker.upper():
                        if instrument.figi.startswith("BBG"):
                            bbg_instruments.append(instrument)
                        elif instrument.figi.startswith("TCS"):
                            tcs_instruments.append(instrument)

                # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º BBG FIGI
                if bbg_instruments:
                    figi = bbg_instruments[0].figi
                    print(f"‚úÖ –ù–∞–π–¥–µ–Ω BBG FIGI: {figi}")
                    return figi

                # –ï—Å–ª–∏ BBG –Ω–µ—Ç, –±–µ—Ä–µ–º TCS
                if tcs_instruments:
                    figi = tcs_instruments[0].figi
                    print(f"‚úÖ –ù–∞–π–¥–µ–Ω TCS FIGI: {figi}")
                    return figi

                print(f"‚ùå –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ —Ç–∏–∫–µ—Ä—É {ticker} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
                return None
            except RequestError as e:
                print(f"‚ùå RequestError –ø—Ä–∏ –ø–æ–∏—Å–∫–µ FIGI –¥–ª—è {ticker}: {e}")
                return None
            except Exception as e:
                print(f"‚ùå –û–±—â–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ FIGI –¥–ª—è {ticker}: {e}")
                return None

    def get_current_price(self, figi_or_ticker: str) -> Optional[float]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞."""
        print(f"üîç –ò—â–µ–º —Ü–µ–Ω—É –¥–ª—è: {figi_or_ticker}")
        figi = figi_or_ticker

        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω —Ç–∏–∫–µ—Ä, –ø–æ–ª—É—á–∞–µ–º FIGI
        if not (figi.startswith("BBG") or figi.startswith("TCS")):
            print(f"üîç –ò—â–µ–º FIGI –¥–ª—è —Ç–∏–∫–µ—Ä–∞: {figi_or_ticker}")
            figi = self._get_figi_by_ticker(figi_or_ticker)
            if not figi:
                print(f"‚ùå FIGI –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —Ç–∏–∫–µ—Ä–∞: {figi_or_ticker}")
                return None
            print(f"‚úÖ –ù–∞–π–¥–µ–Ω FIGI: {figi}")

        with self._get_client() as client:
            try:
                print(f"üåê –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ü–µ–Ω—É –¥–ª—è FIGI: {figi}")
                # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Ü–µ–Ω—É
                response = client.market_data.get_last_prices(figi=[figi])

                print(f"üìä –û—Ç–≤–µ—Ç API: {response}")

                if response.last_prices and len(response.last_prices) > 0:
                    price = response.last_prices[0].price
                    print(f"üí∞ –ü–æ–ª—É—á–µ–Ω–∞ —Ü–µ–Ω–∞: {price.units}.{price.nano}")

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ü–µ–Ω–∞ –Ω–µ –Ω—É–ª–µ–≤–∞—è
                    if price.units == 0 and price.nano == 0:
                        print(
                            "‚ö†Ô∏è  –ü–æ–ª—É—á–µ–Ω–∞ –Ω—É–ª–µ–≤–∞—è —Ü–µ–Ω–∞, –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É —á–µ—Ä–µ–∑ OrderBook"
                        )
                        return self._get_price_from_orderbook(figi, client)

                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏–∑ Quotation –≤ float
                    result = float(f"{price.units}.{price.nano // 1000000:02d}")
                    print(f"‚úÖ –ò—Ç–æ–≥–æ–≤–∞—è —Ü–µ–Ω–∞: {result}")
                    return result
                else:
                    print("‚ùå –ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç API")

                return None
            except RequestError as e:
                print(f"‚ùå RequestError –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω—ã –¥–ª—è {figi_or_ticker}: {e}")
                return None
            except Exception as e:
                print(f"‚ùå –û–±—â–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω—ã –¥–ª—è {figi_or_ticker}: {e}")
                return None

    def _get_price_from_orderbook(self, figi: str, client) -> Optional[float]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É –∏–∑ —Å—Ç–∞–∫–∞–Ω–∞ –∑–∞—è–≤–æ–∫."""
        try:
            print(f"üìñ –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É –∏–∑ OrderBook –¥–ª—è {figi}")
            orderbook = client.market_data.get_order_book(figi=figi, depth=1)

            if orderbook.bids and len(orderbook.bids) > 0:
                bid_price = orderbook.bids[0].price
                result = float(f"{bid_price.units}.{bid_price.nano // 1000000:02d}")
                print(f"‚úÖ –¶–µ–Ω–∞ –∏–∑ OrderBook (bid): {result}")
                return result
            elif orderbook.asks and len(orderbook.asks) > 0:
                ask_price = orderbook.asks[0].price
                result = float(f"{ask_price.units}.{ask_price.nano // 1000000:02d}")
                print(f"‚úÖ –¶–µ–Ω–∞ –∏–∑ OrderBook (ask): {result}")
                return result
            else:
                print("‚ùå OrderBook –ø—É—Å—Ç–æ–π")
                return None

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã –∏–∑ OrderBook: {e}")
            return None

    def get_historical_data(self, figi_or_ticker: str, period: str) -> pd.DataFrame:
        """–ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ. period: '1d', '2d', '1w' –∏ —Ç.–¥."""
        figi = figi_or_ticker

        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω —Ç–∏–∫–µ—Ä, –ø–æ–ª—É—á–∞–µ–º FIGI
        if not (figi.startswith("BBG") or figi.startswith("TCS")):
            figi = self._get_figi_by_ticker(figi_or_ticker)
            if not figi:
                print(f"FIGI –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —Ç–∏–∫–µ—Ä–∞: {figi_or_ticker}")
                return pd.DataFrame()

        # –ü–∞—Ä—Å–∏–º –ø–µ—Ä–∏–æ–¥
        if period == "1d":
            days = 1
        elif period == "2d":
            days = 2
        elif period == "1w":
            days = 7
        else:
            days = 1

        from_time = datetime.now() - timedelta(days=days + 1)
        to_time = datetime.now()

        with self._get_client() as client:
            try:
                response = client.market_data.get_candles(
                    figi=figi,
                    from_=from_time,
                    to=to_time,
                    interval=CandleInterval.CANDLE_INTERVAL_DAY,
                )

                data = []
                for candle in response.candles:
                    data.append(
                        {
                            "Date": candle.time.date(),
                            "Open": float(
                                f"{candle.open.units}.{candle.open.nano // 1000000:02d}"
                            ),
                            "High": float(
                                f"{candle.high.units}.{candle.high.nano // 1000000:02d}"
                            ),
                            "Low": float(
                                f"{candle.low.units}.{candle.low.nano // 1000000:02d}"
                            ),
                            "Close": float(
                                f"{candle.close.units}.{candle.close.nano // 1000000:02d}"
                            ),
                            "Volume": candle.volume,
                        }
                    )

                df = pd.DataFrame(data)
                if not df.empty:
                    df["Date"] = pd.to_datetime(df["Date"])
                    df.set_index("Date", inplace=True)

                return df

            except RequestError as e:
                print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {figi_or_ticker}: {e}")
                return pd.DataFrame()

    def get_trading_volume(
        self, figi_or_ticker: str, date: datetime = None
    ) -> Optional[int]:
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—ä–µ–º —Ç–æ—Ä–≥–æ–≤ –∑–∞ –¥–µ–Ω—å."""
        if date is None:
            date = datetime.now().date()

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∑–∞ –¥–µ–Ω—å
        df = self.get_historical_data(figi_or_ticker, "1d")

        if not df.empty and len(df) > 0:
            return df.iloc[-1]["Volume"]

        return None


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–ª–∏–µ–Ω—Ç–∞
client = TinkoffClient()


# –§—É–Ω–∫—Ü–∏–∏-–æ–±–µ—Ä—Ç–∫–∏ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å yfinance –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
def get_current_price(ticker: str) -> Optional[float]:
    return client.get_current_price(ticker)


def get_historical_data(ticker: str, period: str) -> pd.DataFrame:
    return client.get_historical_data(ticker, period)


def get_trading_volume(ticker: str, date: datetime = None) -> Optional[int]:
    return client.get_trading_volume(ticker, date)
